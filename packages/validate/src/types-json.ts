import { z } from "zod";
import { location, typeId } from "./utils";

const flag = z.enum([
	"Any",
	"Unknown",
	"String",
	"Number",
	"Boolean",
	"Enum",
	"BigInt",
	"StringLiteral",
	"NumberLiteral",
	"BooleanLiteral",
	"EnumLiteral",
	"BigIntLiteral",
	"ESSymbol",
	"UniqueESSymbol",
	"Void",
	"Undefined",
	"Null",
	"Never",
	"TypeParameter",
	"Object",
	"Union",
	"Intersection",
	"Index",
	"IndexedAccess",
	"Conditional",
	"Substitution",
	"NonPrimitive",
	"TemplateLiteral",
	"StringMapping",
	"Reserved1",
	"Reserved2",
	"AnyOrUnknown",
	"Nullable",
	"Literal",
	"Unit",
	"Freshable",
	"StringOrNumberLiteral",
	"StringOrNumberLiteralOrUnique",
	"DefinitelyFalsy",
	"PossiblyFalsy",
	"Intrinsic",
	"StringLike",
	"NumberLike",
	"BigIntLike",
	"BooleanLike",
	"EnumLike",
	"ESSymbolLike",
	"VoidLike",
	"Primitive",
	"DefinitelyNonNullable",
	"DisjointDomains",
	"UnionOrIntersection",
	"StructuredType",
	"TypeVariable",
	"InstantiableNonPrimitive",
	"InstantiablePrimitive",
	"Instantiable",
	"StructuredOrInstantiable",
	"ObjectFlagsType",
	"Simplifiable",
	"Singleton",
	"Narrowable",
	"IncludesMask",
	"IncludesMissingType",
	"IncludesNonWideningType",
	"IncludesWildcard",
	"IncludesEmptyObject",
	"IncludesInstantiable",
	"IncludesConstrainedTypeVariable",
	"IncludesError",
	"NotPrimitiveUnion",
]);

export const resolvedType = z
	.object({
		id: typeId,
		flags: z.array(flag),

		recursionId: z.number().optional(),
		intrinsicName: z
			.enum([
				"any",
				"error",
				"unresolved",
				"unknown",
				"true",
				"false",
				"never",
				"void",
				"symbol",
				"bigint",
				"null",
				"undefined",
				"intrinsic",
				"object",
				"boolean",
				"number",
				"string",
			])
			.optional(),

		firstDeclaration: location.optional(),
		referenceLocation: location.optional(),
		destructuringPattern: location.optional(),

		// TODO, awards for all of these
		typeArguments: z.array(typeId).optional(),
		unionTypes: z.array(typeId).optional(),
		intersectionTypes: z.array(typeId).optional(),
		aliasTypeArguments: z.array(typeId).optional(),

		instantiatedType: typeId.optional(),
		substitutionBaseType: typeId.optional(),
		constraintType: typeId.optional(),
		indexedAccessObjectType: typeId.optional(),
		indexedAccessIndexType: typeId.optional(),
		conditionalCheckType: typeId.optional(),
		conditionalExtendsType: typeId.optional(),
		conditionalTrueType: typeId.optional(),
		conditionalFalseType: typeId.optional(),
		keyofType: typeId.optional(),
		aliasType: typeId.optional(),
		evolvingArrayElementType: typeId.optional(),
		evolvingArrayFinalType: typeId.optional(),
		reverseMappedSourceType: typeId.optional(),
		reverseMappedMappedType: typeId.optional(),
		reverseMappedConstraintType: typeId.optional(),

		isTuple: z.literal(true).optional(),

		symbolName: z.string().optional(),
		display: z.string().optional(),
	})
	.strict();

export type ResolvedType = z.infer<typeof resolvedType>;
export const typesJsonFile = z.array(resolvedType);
export type TypesJsonFile = z.infer<typeof typesJsonFile>;
