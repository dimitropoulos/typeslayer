use crate::analyze_trace::types::{DuplicatedPackage, DuplicatedPackageInstance, NodeModulePaths};
use serde_json;
use std::fs;
use std::path::Path;

pub fn get_package_version(package_path: &str) -> Result<String, String> {
    let package_json_path = Path::new(package_path).join("package.json");

    if !package_json_path.exists() {
        eprintln!(
            "Package.json not found at {}. This may not be a node module.",
            package_json_path.display()
        );
        return Ok("unknown".to_string());
    }

    let json_string = fs::read_to_string(&package_json_path)
        .map_err(|e| format!("Failed to read package.json: {}", e))?;

    let json_obj: serde_json::Value = serde_json::from_str(&json_string)
        .map_err(|e| format!("Failed to parse package.json: {}", e))?;

    Ok(json_obj
        .get("version")
        .and_then(|v| v.as_str())
        .unwrap_or("unknown")
        .to_string())
}

pub fn get_duplicate_node_modules(
    node_module_paths: &NodeModulePaths,
) -> Result<Vec<DuplicatedPackage>, String> {
    let mut duplicates = Vec::new();

    for (package_name, package_paths) in node_module_paths {
        if package_paths.len() < 2 {
            continue;
        }

        let mut instances = Vec::new();
        for package_path in package_paths {
            instances.push(DuplicatedPackageInstance {
                path: package_path.clone(),
                version: get_package_version(package_path)?,
            });
        }

        duplicates.push(DuplicatedPackage {
            name: package_name.clone(),
            instances,
        });
    }

    Ok(duplicates)
}
